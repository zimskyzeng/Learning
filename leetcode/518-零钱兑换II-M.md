# 518-零钱兑换II-M

### 1.题目

给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。

请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。

假设每一种面额的硬币有无限个。 

题目数据保证结果符合 32 位带符号整数。

```
输入：amount = 5, coins = [1, 2, 5]
输出：4
解释：有四种方式可以凑成总金额：
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
```

```
输入：amount = 3, coins = [2]
输出：0
解释：只用面额 2 的硬币不能凑成总金额 3 。
```

```
输入：amount = 10, coins = [10] 
输出：1
```



### 2.解题思路

这道题使用动态规划法来解题。动态规划法从小至大，从局部到整体，通过边界条件为初始条件，后面的求取值参考前面已有的值。

这道题动态规划的大致思路是，我们在已有的`coins`数组中，求取组成`0->amount`金钱各有多少种组合数。边界条件为什么都不取为1种取法。

当`coins=[1,2,5]`时，`coin=1`时，分别组成0至5时的组合有

| Coin | 0(边界条件，什么都不取) |                     1                      | 2           | 3           | 4           |      5      |
| ---- | :---------------------: | :----------------------------------------: | ----------- | ----------- | ----------- | :---------: |
| 初始 |            1            |                     0                      | 0           | 0           | 0           |      0      |
| 1    |            1            | 1=s[1]+s[0] (除本身取法外，剩下数值的取法) | 1=s[2]+s[1] | 1=s[3]+s[2] | 1=s[4]+s[3] | 1=s[5]+s[4] |
| 2    |            1            |     1（不操作，因为2<amont=1无法出现）     | 2=s[2]+s[0] | 2=s[3]+s[1] | 3=s[4]+s[2] | 3=s[5]+s[3] |
| 5    |            1            |     1（不操作，因为5<amont=1无法出现）     | 2（不操作） | 2（不操作） | 3（不操作） | 4=s[5]+[s0] |



### 3.算法实现

```go
func change(amount int, coins []int) int {
    storage := make([]int, amount+1)

	storage[0] = 1
	for _, coin := range coins {
		for i:=1;i<=amount;i++ {
			if i>=coin {
				storage[i] = storage[i]+storage[i-coin]
			}
		}
		//fmt.Printf("%v", storage)
	}
	return storage[amount]
}
```

