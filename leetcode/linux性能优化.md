# linux性能优化

关注性能指标，都离不开“高并发”和“响应快”，这也对应着两个核心指标“吞吐”和“延迟”。



## 一.系统知识原理

### 1.平均负载

平均负载指的是单位时间内，系统处于可运行状态和不可中断状态的进程总数，也就是平均活跃进程数。

- 可运行状态进程

  指正在使用CPU或者正准备使用CPU的进程。

- 不可中断运行状态进程

  指正处于内核态关键流程的进程，并且这些流程是不能被打断的，最常见的是等待硬件的IO响应。比方说当一个进程在向磁盘中写入数据时，是不能被其他进程或者中断打断的。如果打断就容易出现磁盘数据和进程数据不一致的情况出现。

平均负载和CPU使用率没有直接关系，因为平均负载不仅包含了正在使用CPU的进程，还包含了等待硬件IO的进程和等待CPU的进程。

- CPU密集型进程：大量使用CPU会导致平均负载和CPU使用率均升高。
- IO密集型进程：大量IO会导致平均负载升高，但不会使CPU使用率升高。
- 大量进程型：大量进程等待CPU调度(进程间上下文切换)会导致平均负载和CPU使用率均升高。



### 2.CPU上下文切换

CPU运行任何任务都必须依赖的环境，称为CPU上下文。主要包含CPU寄存器和程序计数器。上下文切换，就是把前一个任务的上下文保存起来，加载下一个任务的上下文。

- CPU寄存器是CPU中内置的容量小，但是速度极快的内存。

- 程序计数器用来存储CPU正在执行的指令位置，或即将执行的下一条指令的位置。

**CPU上下文切换的几种场景：**

#### a.进程上下文切换

进程的上下文切换包含虚拟内存、栈、全局变量等用户空间的资源切换，也包含了内核堆栈、寄存器等内核空间的状态切换。

> 区别进程上下文切换与系统调用
>
> 内核空间为Ring0，用户空间为Ring3。当程序需要访问硬件资源时，就会发生系统调用。发生系统调用时，从用户态到内核态发生一次CPU上下文切换，从内核态返回用户态发生一次CPU上下文切换，总共发生2次CPU上下文切换。系统调用过程又称作为特权模式切换，而不是上下文切换。
>
> 主要区别是系统调用发生在同一进程中，而进程上下文切换发生在不同进程中，还会涉及用户空间资源的切换。

#### b.线程上下文切换

进程是操作系统分配资源的基本单位，线程是CPU调度的基本单位。当发生线程上下文切换时，由于同一进程下的线程共享虚拟内存和全局变量，这部分用户空间的资源不需要发生切换，只需切换线程私有数据、寄存器等资源。若线程属于不同的进程时，线程上下文切换和进程上下文切换相同。

#### c.中断上下文切换

为了快速响应硬件事件，中断会打断进程的正常执行和调度。跟进程上下文切换不同，中断上下文切换并不会涉及进程的用户态。中断上下文，仅包括内核态中断程序所必须的状态，如CPU寄存器、内核堆栈、硬件中断参数等。对于同一个CPU来说，中断处理比进程拥有更高的优先级。

CPU上下文切换，一般来说从数百到一万以内，都算是正常。如果切换次数超过一万次，或者切换次数出现指数级别增长时，可能出现了系统性能问题。此外，还要结合自愿上下文切换和非自愿上下文切换两个指标来分析。



### 3.CPU使用率

Linux通过事先定义好的节拍率，触发时间中断，并使用Jiffies记录开机以来的节拍数（可以在`/boot/config-$(uname -r)`查看）。节拍率是内核选项，为了方便用户空间程序，还提供了用户空间节拍率固定值100，表示10ms。

通过读取`/proc/stat`信息，可以获取到自开机以来CPU时间片的分布情况。

```bash
cat /proc/stat | grep cpu
# cpu  27682023 236 27296072 7991231301 2072870 43 406352 0 0 0 
```

每个数值依次为

- user：缩写是us，代表用户态CPU时间，注意这不包括下面的nice时间，但是包括了guest时间。
- nice：缩写是ni，代表低优先级用户态（nice值为1-19的）CPU时间。
- system：缩写是sys，代表内核态CPU时间。
- idle：缩写是id，代表空闲时间，注意这不包括等待IO时间。
- iowait：缩写是wa，代表等待IO的CPU时间。
- irq：缩写是hi，代表处理硬中断的CPU时间。
- softirq：缩写是si，代表处理软中断的CPU时间。
- steal：缩写是st，代表系统运行在虚拟机中，被其他虚拟机占用的CPU时间。
- guest：缩写是guest，代表通过虚拟化运行其他操作系统的时间，即运行虚拟机的时间。
- guest_nice：缩写为gnice，代表低优先级运行虚拟机的时间。

CPU使用率，就是除了空闲时间外，其他时间占总CPU时间的百分比：
$$
CPU使用率 = 1 - \frac {空闲时间}{总CPU时间}
$$
由于`/proc/stat`中记录的是自开机依赖的节拍数，统计的是开机以来的平均CPU使用率，参考意义不大。因此我们会选取最近的一小段时间来计算平均CPU使用率：
$$
平均CPU使用率 = 1 - \frac {空闲时间_{new}-空闲时间_{old}}{总CPU时间_{new}-总CPU时间_{old}}
$$



## 二.性能测试工具

### 1.压力测试工具

#### a.stress

stress是Linux系统压力测试工具。

```bash
# 常用方法
# 模拟1个CPU使用率100%，并持续10分钟
stress --cpu 1 --timeout 600

# 模拟IO压力，即sync
stress -i 1 --timeout 600

# 模拟大量进程(8个进程)
stress -c 8 --timeout 600
```

#### b.ab

ab是常用的压测工具。

```bash
# 常用方法
# 总共发起100个请求，并发10个请求的形式压测
ab -c 10 -n 100 http://xxxx





### 2.性能检查工具

#### a.mpstat

mpstat是常用的多核CPU性能分析工具，可以用来查询每个CPU的性能指标，以及所有CPU的平均指标。

适用场景：系统整体CPU情况

​```bash
# 常用方法
# 查看所有的CPU性能，每隔5秒钟输出一次报告
mpstat -P ALL 5
```





#### b.pidstat

pidstat是常用的进程性能分析工具，可用来查看进程的CPU、内存、IO、上下文切换等核心指标。

适用场景：**进程级别的性能指标，包含CPU、I/O、中断等**。

- cswch：自愿上下文切换。通常指进程无法获取到资源导致的切换，如内存不足，IO问题。
- nvcswch：非自愿上下文切换。通常是时间片到达，被系统强制调度，常见于多个进程争抢CPU。

```bash
# 常用方法
# -u 展示CPU使用信息
# -d 展示I/O信息
# -w 展示任务切换情况
# -t 展示线程级别的指标，默认是进程
# 每隔5秒之后输出一组数据
pidstat -u 5

# 查看每个进程上下文切换的情况
pidstat -w 5 -p PID
```



#### c.vmstat

vmstat是一款常用的系统性能分析工具，主要用来分析系统的内存使用情况，也可以用来分析系统的**中断次数**。

适用场景：**系统总体的性能、中断情况检查。**

其中有以下关键字段：

- cs：每秒上下文切换次数
- in：每秒中断次数
- r：就绪队列长度，即正在运行和等待运行的进程数
- b：处于不可中断休眠的进程数

```bash
# 常用方法
# 每隔5秒钟输出一组数据
vmstat -w 5
```



#### d./proc/interrupts

/proc/interrupts文件展示了系统中所有中断类型的累计次数，可以配合使用watch命令查看中断数量变化的情况。



#### e.perf

perf是Linux2.6.31之后内置的性能分析工具，主要采集性能事件，可以用来分析系统、指定应用程序的各种事件和内核性能。

常用方法1

使用`perf top`来实时追踪热点函数。每列展示情况如下

- Overhead表示该性能事件占所有采样比例。
- Shared表示函数或者指令所在的动态共享对象。
- Object表示动态共享对象的类型。`[.]`表示用户空间可执行程序，`[k]`表示内核空间。
- Symbol表示函数名。

常用方法2

使用`perf record`记录系统采样信息，使用`perf report`来解析展示。